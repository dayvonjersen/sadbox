package template

import (
	"bytes"
	"fmt"
	"strings"
	"text/template/parse"
)

// Default functions from text/template.
var builtins = map[string]interface{}{
	"printf": fmt.Sprintf,
}

// ToJs compiles a text/template to JavaScript. Bwahahaha.
//
// TODO: interface for registering functions: all Go funcs need a JavaScript
// counterpart.
func ToJs(name, template, namespace string) (js string, err error) {
	defer func() {
		//if r := recover(); r != nil {
		//	err = fmt.Errorf("%v", r)
		//}
	}()
	treeSet, err := parse.Parse(name, template, "{{", "}}", builtins)
	if err != nil {
		return "", err
	}
	c := &jsCompiler{escape: true}
	return c.compile(treeSet, namespace), nil
}

// ----------------------------------------------------------------------------

// jsCompiler compiles a text/template to JavaScript. Bwahahaha.
//
// Adapted from com.google.template.soy.jssrc.internal.JsCodeBuilder,
// from the Closure Templates library. Copyright 2008 Google Inc.
type jsCompiler struct {
	b         *bytes.Buffer
	indent    string
	delayed   []string
	escape    bool
	varId     int
	namespace string
}

// increaseIndent increases the current indent by two spaces.
func (c *jsCompiler) increaseIndent() {
	c.indent += "  "
}

// decreaseIndent decreases the current indent by two spaces.
func (c *jsCompiler) decreaseIndent() {
	// check out of range?
	c.indent = c.indent[:len(c.indent)-2]
}

// write appends one or more strings to the generated code.
func (c *jsCompiler) write(parts ...string) *jsCompiler {
	for _, v := range parts {
		c.b.WriteString(v)
	}
	return c
}

// writeIndent appends the current indent to the generated code.
func (c *jsCompiler) writeIndent() *jsCompiler {
	c.b.WriteString(c.indent)
	return c
}

// writeLine is equivalent to c.writeIndent().write(part, "\n").
func (c *jsCompiler) writeLine(parts ...string) *jsCompiler {
	c.writeIndent()
	c.write(parts...)
	c.b.WriteByte('\n')
	return c
}

// addToOutput appends a line/statement with the given concatenation of the
// given JS expressions saved to the current output variable.
func (c *jsCompiler) addToOutput(exprs ...string) {
	c.writeLine("out.append(", strings.Join(exprs, ", "), ");")
}

func (c *jsCompiler) newVariableName() string {
	c.varId++
	return fmt.Sprintf("v%d", c.varId)
}

func (c *jsCompiler) writeNewVariable(value string) string {
	name := c.newVariableName()
	c.writeLine(fmt.Sprintf("var %s = %s;", name, value))
	return name
}

// addDelayed appeds content to be added to the output variable, later.
func (c *jsCompiler) addDelayed(s string) {
	c.delayed = append(c.delayed, s)
}

// addDelayedToOutput appends delayed expressions to the current output
// variable.
func (c *jsCompiler) addDelayedToOutput() {
	if len(c.delayed) > 0 {
		c.addToOutput(c.delayed...)
		c.delayed = c.delayed[:0]
	}
}

// getFunctionName returns a registered function name, including namespace.
func (c *jsCompiler) getFunctionName(ident string) string {
	// TODO: really return function namespace + name.
	return ident
}

func (c *jsCompiler) escapeHTML(s string) string {
	// TODO: turn off escaping depending on settings? conditional escaping?
	if c.escape {
		return fmt.Sprintf("soy.$$escapeHtml(%s)", s)
	}
	return s
}

// WIP
func (c *jsCompiler) compile(treeSet map[string]*parse.Tree, namespace string) string {
	c.b = new(bytes.Buffer)
	// Set a header.
	c.writeLine("// Code generated by gorilla/template.")
	c.writeLine("// Please don't edit this file by hand.")
	// Declare namespaces.
	namespace = strings.Trim(namespace, ".")
	if namespace == "" {
		namespace = "var "
		c.namespace = ""
	} else {
		c.writeLine()
		ns := ""
		for _, name := range strings.Split(namespace, ".") {
			if name != "" {
				if ns != "" {
					ns += "."
				}
				ns += name
				c.writeLine(fmt.Sprintf(
					"if (typeof %s == 'undefined') { var %s = {}; }", ns, ns))
			}
		}
		namespace += "."
		c.namespace = namespace
	}
	// Set a function for each template tree.
	for name, tree := range treeSet {
		c.varId = 0
		c.writeLine()
		c.writeLine(fmt.Sprintf("%s%s = function(opt_data, opt_sb) {",
			namespace, name))
		c.increaseIndent()
		c.writeLine("var out = opt_sb || new soy.StringBuilder();")
		for _, node := range tree.Root.Nodes {
			c.writeNode(node, "opt_data", "")
		}
		c.addDelayedToOutput()
		c.writeLine("return opt_sb ? '' : out.toString();")
		c.decreaseIndent()
		c.writeLine("};")
	}
	return c.b.String()
}

func (c *jsCompiler) writeNode(node parse.Node, dot, final string) {
	switch n := node.(type) {
	case *parse.ActionNode:
		final = c.readNode(n, dot, final)
		if len(n.Pipe.Decl) == 0 {
			c.addDelayed(final)
		} else {
			c.addDelayedToOutput()
			for _, decl := range n.Pipe.Decl {
				c.writeLine(fmt.Sprintf("var %s = %s;", decl.Ident[0], final))
			}
		}
		return
	case *parse.IfNode:
		c.writeIfOrWith(n, dot, final, parse.NodeIf, n.Pipe, n.List,
			n.ElseList)
		return
	case *parse.ListNode:
		if n == nil || len(n.Nodes) == 0 {
			return
		}
		for _, v := range n.Nodes {
			c.writeNode(v, dot, final)
		}
		c.addDelayedToOutput()
		return
	case *parse.RangeNode:
		c.addDelayedToOutput()
		c.escape = false
		newDot := c.writeNewVariable(c.readNode(n.Pipe, dot, final))
		c.writeLine(fmt.Sprintf("if (%s.length > 0) {", newDot))
		c.increaseIndent()
		c.writeLine(fmt.Sprintf("for (var i = 0; i < %s.length; i++) {", newDot))
		c.escape = true
		c.increaseIndent()
		// TODO: hm, must test this.
		newDot = c.writeNewVariable(fmt.Sprintf("%s[i]", newDot))
		c.writeNode(n.List, newDot, final)
		c.decreaseIndent()
		c.writeLine("}")
		c.decreaseIndent()
		if n.ElseList != nil && len(n.ElseList.Nodes) > 0 {
			c.writeLine("} else {")
			c.increaseIndent()
			c.writeNode(n.ElseList, dot, final)
			c.decreaseIndent()
		}
		c.writeLine("}")
		return
	case *parse.TemplateNode:
		c.addDelayedToOutput()
		if dot = c.readNode(n.Pipe, dot, final); dot == "" {
			dot = "null"
		}
		c.writeLine(fmt.Sprintf("%s%s(%s, out);", c.namespace, n.Name, dot))
		return
	case *parse.TextNode:
		if s := strings.TrimSpace(string(n.Text)); s != "" {
			c.addDelayed("'" + s + "'")
		}
		return
	case *parse.WithNode:
		c.writeIfOrWith(n, dot, final, parse.NodeWith, n.Pipe, n.List,
			n.ElseList)
		return
	default:
		panic(fmt.Errorf("writeNode: unexpected node type %T", n))
	}
	panic("unreachable")
}

func (c *jsCompiler) writeIfOrWith(node parse.Node, dot, final string,
	typ parse.NodeType, pipe *parse.PipeNode, list, elseList *parse.ListNode) {
	c.addDelayedToOutput()
	c.escape = false
	newDot := c.writeNewVariable(c.readNode(pipe, dot, final))
	c.escape = true
	c.writeLine(fmt.Sprintf("if (%s) {", newDot))
	c.increaseIndent()
	if typ == parse.NodeWith {
		c.writeNode(list, newDot, final)
	} else {
		c.writeNode(list, dot, final)
	}
	c.decreaseIndent()
	if elseList != nil && len(elseList.Nodes) > 0 {
		c.writeLine("} else {")
		c.increaseIndent()
		c.writeNode(elseList, dot, final)
		c.decreaseIndent()
	}
	c.writeLine("}")
}

func (c *jsCompiler) readNode(node parse.Node, dot, final string) string {
	switch n := node.(type) {
	case *parse.ActionNode:
		return c.readNode(n.Pipe, dot, final)
	case *parse.CommandNode:
		return c.readCommandNode(n, dot, final)
	case *parse.DotNode:
		return dot
	case *parse.FieldNode:
		// TODO: wrap by an JS evaluator (e.g., to read map keys)
		f := fmt.Sprintf("%s.%s", dot, strings.Join(n.Ident, "."))
		return c.escapeHTML(f)
	case *parse.PipeNode:
		if n == nil || n.Cmds == nil {
			return ""
		}
		for _, cmd := range n.Cmds {
			final = c.readNode(cmd, dot, final)
		}
		return final
	case *parse.StringNode:
		return n.Quoted
	default:
		panic(fmt.Errorf("readNode: unexpected node type %T", n))
	}
	panic("unreachable")
}

func (c *jsCompiler) readCommandNode(node *parse.CommandNode, dot, final string) string {
	firstWord := node.Args[0]
	switch n := firstWord.(type) {
	case *parse.IdentifierNode:
		return c.readFunction(n.Ident, node.Args[1:], dot, final)
	default:
		return c.readNode(n, dot, final)
	}
	panic("unreachable")
}

func (c *jsCompiler) readFunction(name string, args []parse.Node, dot, final string) string {
	a := make([]string, len(args))
	for k, v := range args {
		a[k] = c.readNode(v, dot, final)
	}
	if final != "" {
		a = append(a, final)
	}
	return fmt.Sprintf("%s(%s)", c.getFunctionName(name), strings.Join(a, ", "))
}
